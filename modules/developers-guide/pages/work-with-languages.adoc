= Working with different languages
:cpp: C++

Most of the examples in this guide use {proglang}—the programming language specifically designed to work with the {IC}. 
Potentially, however, you can write programs in any language that compiles to WebAssembly to deploy applications that run on the {IC}.
This section provides some high-level guidance for writing programs in different languages and how to deploy them on the {IC}.

== Using Rust

At a high-level, you can create Rust projects to run on the {IC} using Cargo.
The Rust CDK provides some shortcuts to make it easier to write functions as query and update calls, but you can develop applications for the {IC} without using the Rust CDK.

=== Create a project

Because most Rust programmers use Cargo to handle build and package management tasks—such as downloading and compiling the libraries your program depends on—your first step is to create a new Rust project using the Cargo command-line interface.

Alternatively, you could create a new project using {sdk-long-name} instead of Cargo, but creating a project using Cargo represents the typical workflow for creating Rust projects.

To create a new Rust project:

[arabic]
. Open a terminal shell on your local computer, if you don’t already
have one open.
. Verify that you have Cargo installed by running the following command:
+
[source,bash]
----
cargo --version
----
. Change to the folder you are using for your {IC} or Rust sample projects.
. Create a new project by running the following command:
+
[source,bash]
----
cargo new my_rust_program
----
+
This command creates a new `+my_rust_program+` directory with a default `+Cargo.toml+` file and a `+src+` directory with a default `+main.rs+` file.
. Change to your project directory by running the following command:
+
[source,bash]
----
cd my_rust_program
----
+
If you list the contents of this directory, you'll see that it only contains the `+Cargo.toml+` file and `+src+` directory. 
To compile this project to run on the {IC}, you'll need some additional files.

=== Modify the Cargo configuration file

The `+Cargo.toml+` file provides a *manifest* for each Rust package. 
The manifest contains sections that specify configuration details for the package.
To prepare the Rust project to run on the {IC}, we'll modify some of the configuration details in this file.

To modify the `+Cargo.toml+` file:

. Open the `+Cargo.toml+` configuration file in a text editor. 
+
By default, the file contains the `+[package]+` and the `+[dependencies]+` sections.
Projects that run on the {IC} use one `+Cargo.toml+` file to set up a workspace for the canister members of the project and another `+Cargo.toml+` file to configure settings for each canister.
. Copy the `+Cargo.toml+` file to the `+src+` directory by running the following command:
+
[source,toml]
----
cp Casrgo.toml src/Cargo.toml
----
. Open the `Cargo.toml` file in the project root directory and replace the `+[package]+` section with a `+[workspace]+` section:
+
[source,toml]
----
[workspace]
members = [
    "src/my_rust_program",
]
----
+
For information about the `+[workspace]+` section and `+[workspace]+` keys, see link:https://doc.rust-lang.org/cargo/reference/workspaces.html[Workspaces].
For more information about the other sections and keys you can configure in the Cargo.toml file, see link:https://doc.rust-lang.org/cargo/reference/manifest.html[The Manifest Format].
. Remove the `+[dependencies]+` section.
. Save your changes and close the file to continue.

=== Add a canister configuration file

When you create a new project using the {sdk-short-name}, the `+dfx new+` command automatically adds a default `+dfx.json+` configuration file to the project directory.
Because we created the Rust project using Cargo, you need to manually create this file in your project directory.

To add the `+dfx.json+` configuration file:

. Check that you are still in your project directory by running the `+pwd+` command, if necessary.
. Create a new `+dfx.json+` configuration file in the top-level of your project directory, then open the file in a text editor.
. Add the following required keys and settings to the `+dfx.json+` file:
+
[source,json]
----
{
  "version": 1,
  "canisters": {
    "my_rust_program": {
      "type": "custom",
      "candid": "src/my_rust_program.did",
      "wasm": "target/wasm32-unknown-unknown/debug/my_rust_program.wasm",
      "build": "cargo build --target wasm32-unknown-unknown --package my_rust_program"
    }
  }
}
----
+
Let's take a closer look at these settings.
+
--
* The `+version+` setting is used to identify the version of the software used to create the project.
* The `+canisters+` section specifies the name of the project's canisters.
In this case, there's only one canister and it is named `+my_rust_program+`.
* The `+type+` key is set to `+custom+` because this canister is not one of the recognized (`+motoko+` or `+assets+`) canister types.
* The `+candid+` key specifies the name and location of the Candid interface description file to use for this project.
* The `+wasm+` key specifies the path to the WebAssembly file generated by the `+cargo build+` command.
* The `+build+` key specifies the `+cargo+` command used to compile the output.
--
+
These are the minimum settings required.
As you build more complex programs, you might need to include additional configuration details in the `+Cargo.toml+` file, the `+dfx.json+` file, or both files.
. Save your changes and close the file to continue.

== Create a Candid interface description file

In addition to the `+dfx.json+` configuration file, you need to have a Candid interface description file—for example, `+my_rust_program.did+`—to map your program's input parameters and return value formats to their language-agnostic representation in Candid.

To add the Candid interface description file:

. Check that you are still in your project directory by running the `+pwd+` command, if necessary.
. Create a new Candid interface description file—for example, `+my_rust_program.did+`—in the `+src+` directory for your project.
. Open the Candid interface description file in a text editor and add a description for each function the program defines.
+
For example, if the `+my_rust_program+` is a simple program that increments a counter using the `+increment+`, `+read+`, and `+write+` functions, the `+my_rust_program.did+` file might look like this:
+

== Modify the default program

When you create a new project, your project `+src+` directory includes a template `+main.rs+` file with the "Hello, World!" program.

To modify the template source code:

. Open the template `+src/my_rust_program/main.rs+` file in a text editor and delete the existing content.
. Write the program you want to deploy on the {IC}.
. Save your changes and close the `+main.rs+` file.

== Build the program with a local identifier

You are probably only going to use this simple program for some locally testing.
Therefore, there's no need to reserve a unique canister identifier on the {IC} network to hold the compiled output for the program. 

In this scenario, you can compile the program without connecting to an {IC} network at all.
Instead, the `+dfx build+` command creates a local, hard-coded canister identifier for you to use.

You can use this local identifier while you are testing your program or any time you want to compile your program without starting the {IC} replica process locally or connecting to a replica on a remote sub-network.

To build the program executable:

. Open a new terminal and navigate to your project directory.
. Build the program with a locally-defined identifier by running the following command:
+
[source,bash]
----
dfx build --skip-manifest
----
+
You should see output similar to the following:
+
....
Skipping the build manifest. Canister IDs might be hard coded.
Building canisters...
....

== Deploy the project

Before you can deploy this project, you need to connect to the {IC} network either running locally in your development environment or running remotely on a sub-network that you can access.
You must also generate a unique canister identifier to replace your locally-defined identifier.

To deploy this project locally:

. Open a new terminal window or tab on your local computer and navigate to your project directory.
+
For example, click *Shell*, select *New Window*, then run the following command in the new terminal:
+
[source,bash]
----
cd ~/ic-projects/actor_hello
----
. Start the {IC} network on your local computer by running the following command:
+
[source,bash]
----
dfx start --background
----
+
You can use the `+--background+` option to start the Internet Computer network processes then run them in the background. 
+
With this option, you can continue to the next step without opening another terminal shell on your local computer.
. Generate a new canister identifier for your project on the local {IC} network by running the following command:
+
[source,bash]
----
dfx canister create actor_hello
----
+
You should see output similar to the following:
+
....
Jun 12 22:24:18.254 INFO s:0/n:100/ic_execution_environment/canister_manager Successfully created canister, canister_id: ic:0100000000000000000000000000000000012D, subnet_id: 0
....
+
The `+dfx canister create+` command also creates a `+canister_manifest.json+` file in the `+canisters+` directory.
+
For example:
+
....
{
  "canisters": {
    "actor_hello": {
      "candid_path": "/Users/pubs/ic-projects/actor_hello/canisters/actor_hello/actor_hello.did",
      "canister_id": "ic:03000000000000000000000000000000000179",
      "timestamp": "Fri, 12 Jun 2020 21:39:17 +0000",
      "wasm_path": "/Users/pubs/ic-projects/actor_hello/canisters/actor_hello/actor_hello.wasm"
    }
  }
}
....
. Deploy your `+actor_hello+` project on the local network by running the following command:
+
[source,bash]
----
dfx canister install actor_hello
----
+
The command displays output similar to the following:
+
....
Installing code for canister actor_hello, with canister_id ic:03000000000000000000000000000000000179
....

== Query the canister

You now have a program deployed as a *canister* on your local replica network and can test your program by using the `+dfx canister call+` commands.

To test the program you have deployed on the local network:

. Use `+dfx canister call+` to call the `+hello+` function by running the following command:
+
[source,bash]
----
dfx canister call actor_hello hello
----
. Verify that the command returns the text specified for the `+hello+` function along with a checkpoint message in the terminal running the local network process.
+
For example, the program displays "Hello, World! from DFINITY" in output similar to the following:
+
....
debug.print: Hello, World from DFINITY 
....
+
Note that if you are running the Internet Computer network in a separate terminal instead of in the background, the "Hello, World! from DFINITY" message is displayed in the terminal that displays network activity. 


=== Compile the program into WebAssembly

=== Create a minimal configuration file

=== Create a minimal interface description file

=== Connect to a network and deploy

Before you can deploy and test your program, you need to do the following:

* Connect to the {IC} network either running locally in your development environment or running remotely on a sub-network that you can access.
* Register a network-specific identifier for the application.

To deploy and test the application locally:

. Open a new terminal window or tab on your local computer.
+
For example, if running Terminal on macOS,click *Shell*, then select *New Tab* to open a new terminal in your current working directory.
. Start the {IC} network on your local computer in your second terminal by running the following command:
+
[source,bash]
----
dfx start
----
. Register a unique canister identifier for the application by running the following command:
+
[source,bash]
----
dfx canister create --all
----
. Deploy the default program on the local network by running the following command:
+
[source,bash]
----
dfx canister install --all
----
. Test functions in the program from the command-line of in a browser.

== Using C

Because the {IC} supports applications compiled to standard WebAssembly modules, you can use standard compilers and toolchains to build applications in languages such as  C, {cpp}, Objective-C, and Objective-{cpp} programming languages and the `+Clang+` compiler.

To illustrate how to migrate programs written in C to run on the {IC}, let’s look at the simple `+reverse.c+` program in the link:https://github.com/dfinity/examples/tree/master/c[examples] repository. 
The `+reverse.c+` program contains one function—named `+go+`—that reverses a string in place.

=== Set up the development environment

To compile the `+reverse.c+` program into WebAssembly, you need to have the `+clang+` compiler and standard libraries installed. 
You can check whether you have `+clang+` installed on your local computer by running the following command:

[source,bash]
----
clang --version
----

If `+clang+` is installed, the command displays information similar to the following:

....
clang version 10.0.0 
Target: x86_64-apple-darwin19.5.0
Thread model: posix
InstalledDir: /usr/local/opt/llvm/bin
....

If the command doesn’t return version information, install `+clang+` before continuing. 
The steps to install `+clang+` vary depending on the operating system you are using.
On Debian Linux, for example, run the following command:

[source,bash]
----
sudo apt-get install clang lld gcc-multilib
----

On macOS, you can install `+clang+` by installing the Developer Command-Line Tools or by installing LLVM using Homebrew. 
For example, if `+clang+` is not installed, run the following command:

[source,bash]
----
brew install llvm
----

=== Compile the program into WebAssembly

You can compile a C program to run as a WebAssembly module by first compiling using `+clang+`, then linking using `+wasm-ld+`. 
Depending on the operating system and version of `+clang+` you are using, you might use a different version of the WebAssembly linker, such as `+wasm-ld+` on macOS or `+wasm-ld-8+` on Debian. 
 
To compile to WebAssembly on macOS:
 
. Compile the program by running the following clang command:
+
[source,bash]
----
clang --target=wasm32 -c -O3 reverse.c
----
. Run the linker to create the WebAssembly module by running the following `+wasm-ld+` command:
+
[source,bash]
----
wasm-ld --no-entry --export-dynamic --allow-undefined reverse.o -o reverse.wasm
----

=== Create a minimal configuration file

Next, you need to prepare a simple configuration file that identifies the `+reverse+` program binary as a package that can be installed on the {IC} and a `+build+` directory so that you can use the `+dfx+` command-line interface to install and run the package as a canister.

To prepare a configuration file and build directory:

. Create a `+dfx.json+` file with a canisters key by running the following command:
+
[source,bash]
----
echo '{"canisters":{"reverse":{"main":"reverse"}}}' > dfx.json
----
. Create a `+build+` directory for the program by running the following command:
+
[source,bash]
----
mkdir build
----
. Create a `+reverse+` directory for the program by running the following command:
+
[source,bash]
----
mkdir build/reverse
----
. Copy the WebAssembly modules to the new `+build/reverse+` directory by running the following command:
+
[source,bash]
----
cp reverse.wasm build/reverse/
----

=== Create a minimal interface description file

In a standard development workflow, running the `+dfx build+` command creates several files in the `+canisters+` output directory, including one or more Candid interface description (`+.did+`) files that handle type matching for the data types associated with a program’s functions.

For details about the syntax to use for different data types, see the link:../candid-spec/IDL{outfilesuffix}[Candid specification].

To create a Candid interface description file for this program:

. Open a terminal in the `+build+` directory you created for the `+reverse.c+` program source
. Create a new text file named `+reverse.did+`.
. Add a description of the `+go+` function.
+
For example:
+
[source.bash]
----
service : {
  "go": (text) -> (text);
}
----
. Save your changes and close the file to continue.

=== Deploy and test the program

Before you can deploy and test your program, you need to do the following:

* Connect to the {IC} network either running locally in your development environment or running remotely on a sub-network that you can access.
* Register a network-specific identifier for the application.

To deploy and test the application locally:

. Open a new terminal window or tab on your local computer.
+
For example, if running Terminal on macOS,click *Shell*, then select *New Tab* to open a new terminal in your current working directory.
. Start the {IC} network on your local computer in your second terminal by running the following command:
+
[source,bash]
----
dfx start
----
. Register a unique canister identifier for the `+reverse+` application by running the following command:
+
[source,bash]
----
dfx canister create --all
----
. Deploy the default program on the local network by running the following command:
+
[source,bash]
----
dfx canister install --all
----
. Call the `+go+` function in the program by running the following command:
+
[source,bash]
----
dfx canister call reverse go repaid
("diaper")
----

You can find additional examples of C programs in the link:https://github.com/dfinity/examples/tree/master/c[examples] repository.
