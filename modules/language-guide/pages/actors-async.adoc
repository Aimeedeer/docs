= Actors and async data
:proglang: Motoko
:company-id: DFINITY

[[pitch-actors]]
== Each microservice as an _actor_

{proglang} provides an *actor-based* programming model to developers
to express _server behavior_, including that of _micro services_ on the
Internet and the <<internet-computer, Internet Computer>>.

An actor is similar to an object, but is special in that its
isolated state exists _remotely_, and its interactions with the world
are _asynchronous_.

All communication with and between actors involves passing messages
asynchronously over the network using the Internet Computer's
messaging protocol.  An actorâ€™s messages are processed in sequence, so
state modifications never cause race conditions.

The underlying computing platform provided by the Internet Computer
ensures that each message-based synchronization will reach
a close, but in doing so each one may also fail due to the usual
reasons that arise in distributed systems, including time out.

[[pitch-async-actors]]
== Asynchronous actors

Like other _modern_ programming languages, {proglang} permits an ergonomic syntax
for _asynchronous_ communication among components.

In the case of {proglang}, each communicating component is an actor.

As an example of _using_ actors, perhaps as an actor ourselves,
consider this three-line program:

....
let result1 = service1.computeAnswer(params);
let result2 = service2.computeAnswer(params);
finalStep(await result1, await result2)
....

We can summarize the program's behavior with three steps:

* i. First, the program makes two requests (lines 1 and 2), to two
distinct services, each implemented internally as an actor (object).

* ii. Next, on line 3, the program waits for these two results to each
be ready, using the keyword `await` on each result value.

* ii. Finally, on line 3, when both results are available, the program
uses them in the final step, calling the function `finalStep`.

Generally speaking, the services _interleave_ their executions rather
than wait for one another, since doing so reduces overall latency.
However, if we try to reduce latency this way _without_ special
language support, such interleaving will quickly sacrifice clarity and
simplicity.

Even in cases where there are _no_ interleaving executions (for example, if there were only one call above, not two),
the programming abstractions still permit clarity and simplicity,
for the same reason.
Namely, they signal to the compiler where to transform the program, freeing the programmer from contorting the program's logic in order to interleave
its execution with the underlying system's message-passing loop.

Here, the program uses `await` in step ii (line 3) to express that
interleaving behavior in a simple fashion, with human-readable syntax
that is provided by {proglang}.

In language settings that lack these abstractions, developers would
not merely call these two functions directly, but would instead employ
very advanced programming patterns, possibly registering
developer-provided "`callback functions`" within system-provided "`event
handlers`".  Each callback would handle an asynchronous event that
arises when an answer is ready.  This kind of systems-level
programming is powerful, but very error-prone, since it decomposes a
high-level data flow into low-level system events that communicate
through shared state.  Sometimes this style is necessary, but here it
is not.

Our program instead eschews that (cumbersome, indirect) programming
style for this more natural, _direct_ style, where each request
resembles an ordinary function call.  This simpler, stylized
programming form has become increasingly popular for expressing
practical systems that interact with an _external environment_, as
most modern software does today.  However, it requires special
compiler and type-system support, as we discuss in more detail below.

[[pitch-async-behavior]]
=== Support for _asynchronous_ behavior

In an _asynchronous_ computing setting, a program and its running
environment are permitted to perform _internal computations_ that
occur _concurrently_ with one another.

Specifically, asynchronous programs are ones where the program's
requests of its environment do not (necessarily) require the program
to wait for the environment. In the meantime, the program is permitted
to make internal progress within this environment while it waits,
perhaps _actively_. In the example, above, the program makes the
second request while still waiting for the first micro service.

Symmetrically, the environment's requests of the program do not
(necessarily) require the environment to wait for the program's answer
to make external progress around it while it waits for this answer.

We do not show an example of this "`notify`" pattern above, since it
uses callbacks (and _higher-order_ functions and control flow) and is
thus more complex.  However, we discuss <<example-notify,a detailed example>> later in this text.

[[pitch-async]]
=== Syntactic forms `async` and `await`

To address the need for clarity and simplicity, {proglang} adopts the
increasingly-common program constructs `async` and `await`, which
afford the programmer a _structured_ language for describing
potentially-complex asynchronous dependency graphs.

The <<exp-async,syntax `async`>> introduces the _"`promise`" of asynchronous data in
the future_ (not shown in the first example above).  We discuss the introduction of asynchronous promises when we
<<chapter-actors,introduce actors>>.

Here, we merely use the ones that
arise from calling `service1.computeAnswer(params)` and
`service2.computeAnswer(params)`.

The syntax `await` synchronizes on a previously-made promise, and
potentially blocks until the future when this promise is fulfilled by
its producer.  We show two uses of the `await` form in the example
above, which await the results of the two services.

When the developer uses these keywords, the compiler transforms the
program as necessary, often doing complex transformations to the
program's control- and data-flow that would be tedious to perform by
hand.  Meanwhile, the type system of {proglang} enforces certain
correct usage patterns for these constructs, including that types
flowing between consumers and producers always agree, and that the
types of data sent among services are permitted to flow there, and do
not (for example) contain <<chapter-state,private mutable state>>.

== Example: The `counter` object

Consider the following _object declaration_
of the object value `counter`:
....
object counter = {
  var count = 0;
  public func inc() { count += 1 };
  public func read() : Nat { count };
  public func bump() : Nat {
    inc();
    read()
  };
};
....

This declaration introduces a single object instance named `counter`,
whose entire implementation is given above.

In this example, the developer exposes three _public_ functions `inc`,
`read` and `bump` using keyword `public` to declare each in the object
body.  The body of the object, like a <<intro-exp-block,block
expression >>, consists of a list of declarations.

In addition to these three functions, the object has one (private)
mutable variable `count`, which holds the current count, initially
zero.

[[chapter-actors]]
Each {proglang} actor represents a service that one might want to
deploy on the <<internet-computer, Internet Computer>>.

The interface of each actor introduces `async` data whenever it
returns information to its caller.  This programming abstraction
serves a key role in {proglang}, as it coordinates with the
transformations of the {proglang} compiler pipeline and eventual
execution behavior of {proglang} actors on the Internet Computer.

This abstraction represents a _promise_ from the system to the caller,
on behalf of the callee:

 - Either the `async` value, when ``await``ed,
will yield a value from the callee of the expected type,

 - or, an error --- system-level or callee-level --- will eventually arise.

In general, the caller may not _immediately_ `await` each call.  But
even in cases when they do, they use the same `async` and `await`
abstractions, for the same reason: To maintain the illusion of
call-return, direct-style control flow, as supported by the {proglang}
compiler's transformations.

*Technical aside.* In reality, the underlying message-passing of the
system forces the program's logic into another form.  Specifically,
control flow around each actor method call involves the program
loosing control to a system-level message-processing loop, which
forces the program's logic into a so-called
_"continuation-passing-style"_ (CPS) to expose event-handling
_"callback functions"_.  This program structure is complex for humans
to read and maintain, and stands in stark contrast to the direct style
most prefer for most program logic.

We note that {proglang} programs may avoid callbacks for many cases,
but not _all_ cases where they are used in other asynchronous,
message-passing settings.  Notably, callbacks are still needed when
they serve as a fundamental aspect of the service's interface, as with
a <<example-notify,notification service>>, where users register with
the service to get notified some times later, when some predetermined
class of events, occur over time.

'''

To start, we consider the simplest stateful service: A counter with
a single "current count" value.

== Example: a Counter service

Consider the following actor object (a value form):

....
actor Counter {
  var count : Nat = 0;

  public func increment() : async () {
    count += 1;
  };

  public query func get_current() : async Nat {
    count
  };

  public func set_current(n: Nat) : async () {
    count := n;
  };
}
....

CAUTION: todo: discuss counter example

== Using `async` values by ``await``-ing their answer values

To get the underlying content of an `async` value, such as a return
value from `get_current` above, the caller uses `await`:

....
let a : async Nat = counter.get_current()
let c : Nat = await(counter.get_current())
....

The first line gets _a promise of the current value_ (the variable `a`),
but does not wait for it, and thus cannot use it as a natural number.

The second line immediately inspects this promise and gets the natural
number, or waits until it is ready.

NOTE: For now, the {proglang} compiler gives an error for calls that
do not follow this second form, which is currently required to ensure
that certain program resources will always be reclaimed.

== Actor classes generalize an actor's initial state

An actor class defines a constructor function that produces objects of
a predetermined type, with a predetermined interface and behavior.

For example, we can generalize `Counter` given above to `CounterInit`
below, by introducing a constructor parameter, variable `init` of type
`Nat`:

....
actor class CounterInit(init: Nat) {
  var count : Nat = init;

  public func increment() : async () {
    count += 1;
  };

  public query func get_current() : async Nat {
    count
  };

  public func set_current(n: Nat) : async () {
    count := n;
  };
}
....

To use this class, we can create several actors with different initial
values:

....
let c1 = CounterInit(1);
let c2 = CounterInit(2);
....

The two lines above _instantiate_ the actor class twice, once per
line.  The first invocation uses the initial value `1`, where the
second uses initial value `2`.  Their interface is common, and in
terms of their types, they are compatible and can be used
interchangeably.

NOTE: For now, the {proglang} compiler gives an error when compiling
programs that do not consist of a single actor.  The interpreter
accommodates the examples above.
